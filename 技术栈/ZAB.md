# ZAB(zookeeper原子广播协议)
ZAB协议是专门为Zookeeper设计的一种支持崩溃恢复的原子广播协议，因为当ZAB协议中的Leader角色崩溃时，ZAB协议中有Leader重新选举功能。

## ZAB协议中的角色
1. Leader(领导者)：

事务请求的唯一处理者，负责发出事务Proposal，也可以处理客户端的读请求

2. Follower(跟随者)：

对Leader发出的事务Proposal具有投票权，将客户端写的事务请求转发给Leader，处理客户端的读请求，并且可以参与Leader的选择

3. Observer(观察者)：

用于提高Follower的读性能，当读请求并发量上来的时候，Observer可以分担一部分的读请求，有人可能会这么想，我们也可以增加Follower节点的数量，
来扛住并发量，如果我们一旦增加Follower节点数量的话，那么事务Proposal(提案)的投票表决和Leader的选举的效率就会降低。
Observer不参与Leader的选举。
ZAB协议类似于Paxos算法，是一种Paxos算法在工业上的实现。

## ZAB协议的两种基本模式
### 消息广播模式
消息广播类似于一个二阶段提交过程。Zookeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，
此消息广播协议基于FIFO队列，将需要广播的事务Proposal(提案)依次放入队列中，采用TCP通信。

#### 广播过程
1. Leader发送事务提案(proposal)

针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并为该事务Proposal分配一个全局递增的唯一ZXID，
ZXID由64位组成，其中高32位表示epoch(每个Leader的周期，年号)，低32位表示xid事务id，然后将事务Proposal发送给Follower进行投票表决

2. Follower接收提案并响应ACK

Follower接受到了事务Proposal请求后，并会对其进行投票，返回ACK响应。

3. Leader广播Commit消息

如果Leader收到半数以上的ACK响应后，就会广播一个Commit消息给Follower通知其进行事务提交

###  崩溃恢复模式
以前说到如果在消息广播模式中，如果一旦出现Leader服务器崩溃，那么就会进入到崩溃恢复模式，
在ZAB协议中，为了保证程序的正常运行，需要重新在Follower中选举一个新的Leader

#### Leader选举两个场景
一个是服务器初始化启动，另一个是Leader服务器崩溃。

#### looking状态
当需要在集群中选举一个Leader，这种选举状态被称为"LOOKING"，当服务器处于LOOKING状态的时候，那么它就会向集群中所有机器发送消息，称这个消息为"投票"。

#### 服务器SID与事务ZXID
消息包含两个基本信息：所举荐服务器的SID和ZXID，投票信息就是(<SID>,<ZXID>)， 分别表示服务器唯一标识和事务ID。SID是在启动zookeeper进行设置的myid。

#### 选举规则
首先会选举ZXID最大的服务器称为Leader，因为ZXID峰值代表事务是最新的，数据是最新的，如果ZXID相等的话，那么SID较大的服务器就会成为Leader

#### 选举投票过程

- 假设三台服务器投票信息为：(1, 9), (2, 8), (3, 8)SID分别是 1, 2, 3；ZXID分别是 9, 8, 8。在第一次投票的时候，都会投票给自己，再将自己的投票信息分别发送给其他机器。

- 当机器1接收到另外两台机器发送过来的投票信息(2, 8), (3, 8)，发现他们的ZXID都没有自己的ZXID=9大，那么不会修改投票结果，坚持投票给自己

- 当机器2接受到(1, 9), (3, 8)时，假设先收到(3, 8)，发现它的ZIXD跟自己的ZXID=8相等，然后就会比较SID，发现它的SID比自己的SID=2大，那么就会投票给机器3了，后面再接受到了(1, 9)发现比机器3的ZXID=8要大，后面又会修改投票结果，将投票投给机器1

- 当机器3接受到(1, 9), (2, 8)，假如先收到(2, 8)，发现它的ZXID跟自己的ZXID=8相等，然后比较SID，发现比自己的小，那么不会修改自己的投票结果，坚持投票给自己，后面再接受到了(1, 9)发现比自己的ZXID=8要大，后面又会修改投票结果，将投票投给机器1

- 最后，三台都投给机器1，获得的投票数超过了半数，即机器1就会当选为Leader服务器

#### 数据同步
崩溃恢复模式中，当Leader选举完成之后，要进行数据同步，因为事务日志可能存在还没有被提交的事务，即是否完成数据同步。

#### 同步过程
- 首先Leader服务器会首先确认事务日志中的所有Proposal是否都已经被集群中过半的机器提交了

- 如果没有的话，Leader服务器会向那么没有被Follower服务器同步的事务以Proposal消息的形式逐个发送给Follower服务器，并在每一个Proposal消息后面紧接着再发送一个Commit消息，表示该事务已经被提交

- 等到Follower服务器将所有尚未同步的事务Proposal同步过来成功应用到本地数据库后，Leader服务器就可以接受客户端的事务请求了，然后提出新的提案了

## ZAB与Paxos总结
总的来说，ZAB协议提交事务提案的过程跟Paxos有点类似，都是由Leader发送给下面的Follower，让Follower进行投票表决，都是超过半数以上才会通过。
但是ZAB协议比Paxos多的是崩溃恢复模式，也就是Leader崩溃时，能够自我恢复。所以ZAB协议跟Paxos算法最主要的区别就是：两个设计的目标不同，
ZAB协议主要用于构建一个高可用的分布式数据的主备系统，因为有崩溃恢复，Leader崩溃能够重新选举，达到一个高可用的目的。
而Paxos算法目的在于构建一个分布式数据一致性系统，强调的是数据的一致性，当Proposer提议者崩溃时不能自我恢复，从而丢失高可用的功能


## 数据节点
Znode将节点分为持久节点和临时节点。
- 持久节点
  持久节点一旦创建，只要不主动移除，他将永远存在于zk的系统中。
- 临时节点
  临时节点与创建它的客户端会话相关联，一旦会话结束，客户端创建的临时节点将自动删除。

值得注意的是，只有持久节点可以拥有子节点，临时节点不能拥有子节点。

在分布式系统中，顺序号可以被用于为所有事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序        
临时节点适合动态上下线


## 脑裂
因为心跳超时，可能是master挂了，可能是master，zookeeper之间的网络出现问题，这时候就是假死。
slaver中选取一个新的master，原来的master并未死掉，这时候就出现了两个master。
每选取一个新的leader，会生成一个epoch，这个epoch是递增的。
follower确认新的leader存在，知道起epoch，就会拒绝epoch小于现任leader epoch的所有请求。


