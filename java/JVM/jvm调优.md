###调优的目的
调优的目的是为了减少GC，核心目标减少full GC

- -Xms 设置初始分配大小，默认为物理内存的1/64
- -Xmx 最大分配内存，默认为物理内存的1/4
- -XX:+PrintGCDetails 输出详细的GC处理日志

-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseG1GC

**注意：参数调优一定要初始大小和最大分配内存的大小要一致**

### 何时需要做JVM调优
1.Heap内存（老年代）持续上涨达到设置的最大内存值
2.Full GC次数频繁
3.GC停顿时间过长（超过1s）
4.应用出现OutOfMemory等内存异常
5.应用中有使用本地缓存且占用大量内存空间
6.系统吞吐量与性能不高或下降


### 哪些对象可以作为GC Roots
1.虚拟机栈（栈帧中的本地变量表）中引用的对象
2.方法区中静态属性引用的对象
3.方法区中常量引用的对象
4.本地方法栈中JNI（即一般说的Native方法）引用的对象

### GC中Stop The World(STW)
在执行垃圾收集算法时，Java应用程序的其他所有除了垃圾收集收集器线程之外的线程都被挂起。
此时，系统只能允许GC线程进行运行，其他线程则会全部暂停，等待GC线程执行完毕后才能再次运行。
这些工作都是由虚拟机在后台自动发起和自动完成的，是在用户不可见的情况下把用户正常工作的线程全部停下来，
这对于很多的应用程序，尤其是那些对于实时性要求很高的程序来说是难以接受的。
但不是说GC必须STW，你也可以选择降低运行速度但是可以并发执行的垃圾算法，这取决于你的业务。

### JVM为什么设置STW
不停掉用户线程，会使的对象一会不是垃圾一会是垃圾
比如开始垃圾回收，线程还没结束，引用的对象不是垃圾，但是执行过程中，用户线程执行结束，此时之前引用的对象变成垃圾。

### Minor GC和Full GC触发条件
- Minor GC触发条件：当Eden区满时，触发Minor GC
- Full GC触发条件：
1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

### 对象什么时候进入老年代
1. 大对象直接进入老年代。虚拟机提供了一个阈值参数，令大于这个设置值的对象直接在老年代中分配，如果大对象进入新生代，新生代采用的复制算法收集内存，会导致在Eden区和两个Survivor区之间发生大量的内存复制，应该避免这种情况
2. 长期存活的对象进入老年代。虚拟机给每个对象定义了一个年龄计数器，对象在Eden区出生，经过一次Minor GC后仍然存活，并且能被Survivor区容纳的话，将被移动到Survivor区中，此时对象的年龄设为1，然后对象在Survivor区中每熬过一次Minor GC，年龄就增加1，当年龄超过设定的阈值时，就会被移动到老年代中。
3. 动态对象年龄判定：如果在Survivor空间中所有相同年龄的对象，大小总和大于Survivor空间的一半，那么年龄大于或等于该年龄的对象就直接进入老年代，无需等到阈值中要求的年龄
4. 空间分配担保：如果老年代中最大可用的连续空间大于新生代所有对象的总空间，那么Minor GC是安全的，如果老年代中最大可用的连续空间大于历代晋升到老年代的对象的平均大小，就进行一次有风险的Minor GC,如果小于平均值，就进行Full GC来让老年代腾出更多的空间。因为新生代使用的是复制算法，为了内存利用率，只是使用其中一个Survivor空间来做轮换备份，如果大量对象在Minor GC后仍然存活，导致Survivor空间不够用，就会通过分配担保机制，将多出来的对象提前转到老年代，但老年代要进行担保的前提是自己本身还有容纳这些对象的剩余空间，由于无法提前知道会有多少对象存活下来，所以取之前每次晋升到老年代的对象的平均大小作为经验值，与老年代的剩余空间做比较